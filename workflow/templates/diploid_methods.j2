## Description of methods used to generate the stratifications

Heterozygous (and homozygous by complement) regions were generated using a
process loosely inspired by dipcall. The main deviation is that in this case,
one haplotype is aligned to the other to produce a list of variants and
alignment breaks (corresponding to large structural variation) rather than
aligning two haplotypes to a reference. The mirror of this process is done on
the other haplotype, producing pairs of bed files representing hets with respect
to the coordinate system on each haplotype.

*Disclaimer:* The following code is for descriptive purposes only. The commands
and parameters match what was actually run, but one must consult the actual code
for exact execution since some intermediate processing was required to chain the
commands together and were not shown here for brevity.

### Variants

Alignments were generated by aligning one haplotype to the other using
`minimap` with the following:

```
minimap2 -a --cs -z200000,10000,200 -xasm5 <this_hap> <other_hap> > <output>
```

Using the `dipcall-aux.js` script from `dipcall`, low quality (less than 50kb,
mapping quality less than 5, unmapped flag set) alignments were removed and the
remainder were sorted:

```
k8 dipcall-aux.js samflt <minimap_sam_output> | \
samtools sort > <output>
```

This was then converted to a VCF which was then converted to a bed (with variant
length in the 4th column for filtering):

```
htsbox pileup -q5 -evcf <hap.fa> <hap.bam> | \
grep -v '^#' | \
awk 'OFS="\t" {
  ref = length($4);
  alt = length($5);
  print $1, $2-1, $2+length($4)-1, (ref>alt) ? ref-alt : alt-ref
}' > <output>
```

This was then filtered to produce a bed subset to SNV or SV variants (where SVs
have a variant length >= 50 base pairs):

```
awk '$4>=50 || ($4==0 && ($3-$2==1))' <bed_from_above> | \
cut -f1,2,3 > <output>
```

In subsequent sections, this bed is referred to as `SNVorSV_variants_bed` and
the bed from which this was derived is referred to as `all_variants_bed`.

### Alignment Breaks

Similar to the above (and also following the intention of dipcall) on hap was
aligned to the other to produce a paf file:

```
minimap2 -c --paf-no-hit --cs -z200000,10000,200 -xasm5 <this_hap> <other_hap> \
  > <output>
```

These were then converted to a bed using `paftools`:

```
sort -k6,6 -k8,8n <minimap_output> | \
k8 paftools.js call - 2> {log} | \
grep ^R | \
cut -f2,3,4 > <output>
```

Since this bed file represented regions covered by alignments, we inverted it
with `complementBed` since we are interested in the opposite (regions not
covered by an alignment, ie a break).

This bed file is referred to as the `breaks_bed` below.

### Union Het Beds

Master beds for all hets or SNV/SV hets were created by union-ing the following
with `multiIntersectBed` and `mergeBed`:

- `breaks_bed` + `all_variants_bed` -> `all_hets_bed`
- `breaks_bed` + `SNVorSV_variants_bed` -> `SNVorSV_hets_bed`

These two beds were processed in parallel using the same steps in the next
section.

### Merging at varying distances

Since we are interested in regions "within <k> basepairs from a het", we
exteneded each region in the above union bed files using `slopBed` and then
merged overlaps using `mergeBed`. Additionally, non-PAR on the X/Y chromosomes
were removed, since these regions are effectively haploid and thus are
meaningless in this analysis.

These resulting bed files were then complemented using `complementBed` to
produce bed files representing "homozygous regions", which really means "regions
that are further away than <k> bases from a het".

## Software

### General Bedtools Steps

{% for dep, version in bedtools_deps.items() %}
- {{ dep }}: version {{ version }}
{%- endfor %}

### Alignment Steps

{% for dep, version in dipcall_deps.items() %}
- {{ dep }}: version {{ version }}
{%- endfor %}

